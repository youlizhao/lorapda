%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Written by Zhirong Tang
% Date:     2022-03-14
% Update:   2022-03-15
% LoRa Physical Layer Modulator/Demodulator/Encoder/Decoder
%
% TODO:     [] support explicit header
%           [] support low data rate optimization
%           [] better preamble detection algo
%           [] better CFO&TO elimation algo
% 
% FIXME:    [] interleave zero-padding problem (different from COTS LoRa)
% 
% Reference: 
%           https://github.com/tapparelj/gr-lora_sdr
%           https://github.com/jkadbear/LoRaPHY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

classdef LoRaPHY < handle & matlab.mixin.Copyable
    properties
        rf_freq                 % carrier frequency
        sf                      % spreading factor (7,8,9,10,11,12)
        bw                      % bandwidth (125kHz 250kHz 500kHz)
        fs                      % sampling frequency
        cr                      % code rate: (1:4/5 2:4/5 3:4/7 4:4/8)
        has_header              % explicit header: 1, implicit header: 0 (supported)
        ldr                     % Low Data Rate Optimization: enable: 1 (supported), disable: 0
        crc                     % CRC Check: enable: 1(supported), disable: 0
        preamble_len            % preamble length
        payload_len             % payload length
        symbol_len              % number of symbols within packet
        crc_generator           % CRC generator with polynomial x^16+x^12+x^5+1
        whitening_seq           % whitening sequence
        
        sig                     % baseband signal
        upchirp                 % chirp with increasing frequency from -bw/2 to bw/2
        downchirp               % chirp with decreasing frequency from -bw/2 to bw/2
        num_bb_samples          % number of baseband sample points per symbol
        num_brb_samples         % number of broadband sample points per symbol
        num_samples             % number of sample points per symbol
        bin_size                % number of bins after FFT (with zero padding)
        zero_padding_ratio      % FFT zero padding ratio
        fft_size                % FFT size
        preamble_bin            % reference bin in current decoding window, used to eliminate CFO
        cfo                     % carrier crequency offset
        is_lowpass              % set `true` to use lowpass filter
        
        debug_phy               % set `true` for debug information
        debug_en_ham            % set `true` for enable hamming code error correction
    end
    
    methods
        function self = LoRaPHY(rf_freq, sf, bw, fs, cr, payload_len)
            % LoRaPHY Constructor
            if verLessThan('matlab', '9.7')
                error('Error. Newer version of MATLAB is required ( >=R2019b ).');
            end
            if nargin == 4
                self.cr = 1;
            elseif nargin == 5
                self.cr = cr;
            elseif nargin == 6
                self.cr = cr;
                self.payload_len = payload_len; 
            end
            
            self.rf_freq = rf_freq;
            self.sf = sf;
            self.bw = bw;
            self.fs = fs;
            self.has_header = 0;
            self.crc = 1;
            self.preamble_len = 8;
            
            if ~self.has_header
               if isempty(self.payload_len)
                   error('Error. Payload_len must be specific in implicit header mode.');
               end
            end
            
            self.zero_padding_ratio = 10;
            self.cfo = 0;
            
            self.is_lowpass = false;
            
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % The whitening sequence is generated by an LFSR
            % x^8+x^6+x^5+x^4+1
            % Use the code below to generate such sequence
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % reg = 0xFF;
            % for i = 1:255
            %     fprintf("0x%x, ", reg);
            %     reg = bitxor(bitshift(reg,1), bitxor(bitget(reg,8), bitxor(bitget(reg,6), bitxor(bitget(reg,5), bitget(reg,4)))));
            % end
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            self.whitening_seq = uint8([0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe1, 0xc2, 0x85, 0xb, 0x17, 0x2f, 0x5e, 0xbc, 0x78, 0xf1, 0xe3, 0xc6, 0x8d, 0x1a, 0x34, 0x68, 0xd0, 0xa0, 0x40, 0x80, 0x1, 0x2, 0x4, 0x8, 0x11, 0x23, 0x47, 0x8e, 0x1c, 0x38, 0x71, 0xe2, 0xc4, 0x89, 0x12, 0x25, 0x4b, 0x97, 0x2e, 0x5c, 0xb8, 0x70, 0xe0, 0xc0, 0x81, 0x3, 0x6, 0xc, 0x19, 0x32, 0x64, 0xc9, 0x92, 0x24, 0x49, 0x93, 0x26, 0x4d, 0x9b, 0x37, 0x6e, 0xdc, 0xb9, 0x72, 0xe4, 0xc8, 0x90, 0x20, 0x41, 0x82, 0x5, 0xa, 0x15, 0x2b, 0x56, 0xad, 0x5b, 0xb6, 0x6d, 0xda, 0xb5, 0x6b, 0xd6, 0xac, 0x59, 0xb2, 0x65, 0xcb, 0x96, 0x2c, 0x58, 0xb0, 0x61, 0xc3, 0x87, 0xf, 0x1f, 0x3e, 0x7d, 0xfb, 0xf6, 0xed, 0xdb, 0xb7, 0x6f, 0xde, 0xbd, 0x7a, 0xf5, 0xeb, 0xd7, 0xae, 0x5d, 0xba, 0x74, 0xe8, 0xd1, 0xa2, 0x44, 0x88, 0x10, 0x21, 0x43, 0x86, 0xd, 0x1b, 0x36, 0x6c, 0xd8, 0xb1, 0x63, 0xc7, 0x8f, 0x1e, 0x3c, 0x79, 0xf3, 0xe7, 0xce, 0x9c, 0x39, 0x73, 0xe6, 0xcc, 0x98, 0x31, 0x62, 0xc5, 0x8b, 0x16, 0x2d, 0x5a, 0xb4, 0x69, 0xd2, 0xa4, 0x48, 0x91, 0x22, 0x45, 0x8a, 0x14, 0x29, 0x52, 0xa5, 0x4a, 0x95, 0x2a, 0x54, 0xa9, 0x53, 0xa7, 0x4e, 0x9d, 0x3b, 0x77, 0xee, 0xdd, 0xbb, 0x76, 0xec, 0xd9, 0xb3, 0x67, 0xcf, 0x9e, 0x3d, 0x7b, 0xf7, 0xef, 0xdf, 0xbf, 0x7e, 0xfd, 0xfa, 0xf4, 0xe9, 0xd3, 0xa6, 0x4c, 0x99, 0x33, 0x66, 0xcd, 0x9a, 0x35, 0x6a, 0xd4, 0xa8, 0x51, 0xa3, 0x46, 0x8c, 0x18, 0x30, 0x60, 0xc1, 0x83, 0x7, 0xe, 0x1d, 0x3a, 0x75, 0xea, 0xd5, 0xaa, 0x55, 0xab, 0x57, 0xaf, 0x5f, 0xbe, 0x7c, 0xf9, 0xf2, 0xe5, 0xca, 0x94, 0x28, 0x50, 0xa1, 0x42, 0x84, 0x9, 0x13, 0x27, 0x4f, 0x9f, 0x3f, 0x7f]');
            
            self.crc_generator = comm.CRCGenerator('Polynomial','X^16 + X^12 + X^5 + 1');
            
            self.debug_phy = false;
            self.debug_en_ham = true;
            
            self.init();
        end
        
        function init(self)
            % init Initialize some parameters
            self.num_bb_samples = 2^self.sf;
            self.num_samples = 2*self.num_bb_samples;
            self.num_brb_samples = round((self.fs/self.bw)*self.num_bb_samples);
            self.bin_size = self.num_bb_samples * self.zero_padding_ratio;
            self.fft_size = self.num_samples * self.zero_padding_ratio;
            
            self.upchirp = LoRaPHY.chirp(self.sf, self.bw, 2*self.bw, 0, true);
            self.downchirp = LoRaPHY.chirp(self.sf, self.bw, 2*self.bw, 0, false);
            
            % Low Data Rate Optimization (LDRO) mode in LoRa
            % If the chirp peird is larger than 16ms, the least significant
            % two bits are considered unreliable and are neglected.
%             if 2^(self.sf)/self.bw > 16e-3
%                 self.ldr = 1;
%             else
%                 self.ldr = 0;
%             end
            self.ldr = 0;
            
            self.symbol_len = self.calc_sym_num(self.payload_len);
        end
        
        function y = modulate(self, symbols, fs)
            % modulate  Modulate a baseband signal
            %
            % input:
            %     symbols: A vector of chirp symbols to be modulated
            %              valid symbol range: 0 to 2^sf-1
            % output:
            %     y: A valid LoRa baseband signal
            if nargin == 2
                fs_ = self.fs;
            elseif nargin == 3
                fs_ = fs;
            end
            
            uc = LoRaPHY.chirp(self.sf, self.bw, fs_, 0, true);
            dc = LoRaPHY.chirp(self.sf, self.bw, fs_, 0, false);
            preamble = repmat(uc, self.preamble_len, 1);
            netid = [LoRaPHY.chirp(self.sf, self.bw, fs_, 24, true); LoRaPHY.chirp(self.sf, self.bw, fs_, 32, true)];
            
            chirp_len = length(uc);
            sfd = [dc; dc; dc(1: round(chirp_len/4))];
            data = zeros(length(symbols)*chirp_len, 1);
            for i = 1:length(symbols)
                data((i-1)*chirp_len+1:i*chirp_len) = LoRaPHY.chirp(self.sf, self.bw, fs_, symbols(i), true);
            end
            
            y = [preamble; netid; sfd; data];
        end
        
        function y = real_modulate(self, symbols, amp, phase, cfo, to)
            % real_modulate  Modulate a baseband signal with manual defined 
            % amplitude, phase, cfo and to
            %
            % input:
            %     symbols: A vector of chirp symbols to be modulated
            %              valid symbol range: 0 to 2^sf-1
            %     amp: amplitude
            %     phase: random phase
            %     cfo: carrier frequency offset
            %     to: sample points that signal arrives before demod window
            % output:
            %     y: A valid LoRa baseband signal
            
            fs_bw_rat = self.fs/self.bw;
            lcm_ = lcm(fs_bw_rat, 100);     % least common multiple
            fs_ = lcm_*self.bw;
            bb_sig = self.modulate(symbols, fs_);
            
            n = 1/lcm_;
            % add cfo
            bb_sig = bb_sig .* (exp(1j*2*pi* cfo./self.bw * (0:n:n*length(bb_sig)-n).'));
            % add to
            bb_sig = [zeros(round(lcm_*to), 1); bb_sig];
            % add amp & phase
            y = amp * phase * bb_sig;
            % resample to fs
            % y = resample(y, self.fs, fs_);
            y = y(1: lcm_/fs_bw_rat: end);
        end
        
        function [symbols_m, cfo_m, netid_m, x_start, sfo_drift_m] = demodulate(self, sig)
            % demodulate  LoRa packet demodulation
            %
            % input:
            %     sig: Baseband signal in complex
            % output:
            %     symbols_m: A matrix containing the demodulated results.
            %                Each column vector represents the symbols of
            %                a successfully demodulated packet.
            %     cfo_m: A vector containing the carrier frequency offset
            %            results. Each element represents the CFO of the
            %            packet in symbols_m.
            %     netid_m: A matrix containing the netid of demodulated
            %              packets.
            %     x_start: A vector containing the start index of packets.

            self.cfo = 0;
            self.init();
            
            % resample signal with 2*bandwidth
            if self.is_lowpass
                sig = lowpass(sig, self.bw/2, self.fs);
            end
            self.sig = resample(sig, 2*self.bw, self.fs);

            symbols_m = [];
            cfo_m = [];
            netid_m = [];
            x = 1;
            x_start = [];
            sfo_drift_m = [];
            while x < length(self.sig)
                x = self.detect(x);
                if x < 0
                    break;
                end

                % align symbols with SFD
                x = self.sync(x);
                x_start = [x_start;x - (self.preamble_len + 4.25)*self.num_samples];

                % NetID
                pk_netid1 = self.dechirp(round(x-4.25*self.num_samples));
                pk_netid2 = self.dechirp(round(x-3.25*self.num_samples));
                netid_m = [netid_m;
                    [mod((pk_netid1(2)+self.bin_size-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf), ...
                    mod((pk_netid2(2)+self.bin_size-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf)]
                ];

                % the goal is to extract payload_len from PHY header
                % header is in the first 8 symbols
                symbols = [];
                pk_list = [];
                if x > length(self.sig) - 8*self.num_samples + 1
                    return;
                end
                
                % number of symbols in the packet
                sym_num = self.calc_sym_num(self.payload_len);

                % demodulate the rest LoRa data symbols
                if x > length(self.sig) - sym_num*self.num_samples + 1
                    return;
                end
                
                for ii = 0:sym_num-1
                    self.plot_fft(x+ii*self.num_samples);
                    pk = self.dechirp(x+ii*self.num_samples);
                    pk_list = [pk_list; pk];
                    symbols = [symbols; mod((pk(2)+self.bin_size-self.preamble_bin)/self.zero_padding_ratio, 2^self.sf)];
                end
                x = x + sym_num*self.num_samples;

                % compensate CFO drift
                [symbols, sfo_drift] = self.dynamic_compensation(symbols);

                symbols_m = [symbols_m mod(round(symbols),2^self.sf)];
                cfo_m = [cfo_m self.cfo];
                sfo_drift_m = [sfo_drift_m sfo_drift];
            end

            if isempty(symbols_m)
                warning('No preamble detected!');
            end
        end
        
        function symbols = encode(self, payload)
            % encode  Encode bytes to symbols
            %
            % input:
            %     payload: Payload of LoRa packet
            % output:
            %     symbols: A vector representing the symbols of the packet
            if self.crc
                data_w = uint8([payload; self.calc_crc(payload)]);
            else
                data_w = uint8(payload);
            end
            
            plen = self.payload_len;
            % whitening
            data_w(1:plen) = self.whitening(data_w(1:plen));
            % bytes to nibbles
            nibbles = zeros(2*plen, 1);
            for i = 1: length(data_w)
                nibbles(2*i-1) = bitand(data_w(i), 0xf);
                nibbles(2*i) = bitshift(data_w(i), -4);
            end
            % hamming encode
            codewords = self.hamming_encode(nibbles);
            % interleave
            symbols_i = self.interleave(codewords);
            % gray decode
            symbols = self.gray_decoding(symbols_i);
        end
        
        function [data, crc_check] = decode(self, symbols)
            % decode  Decode symbols to bytes
            %
            % input:
            %     payload: symbols of LoRa packet
            % output:
            %     data: Decoded payload of LoRa packet
            %     crc_check: valid: 1, invalid: 0
            
            % gray encode
            symbols_g = self.gray_encoding(symbols);
            % deinterleave
            symbols_di = self.deinterleave(symbols_g);
            % hamming decode
            nibbles = self.hamming_decode(symbols_di);
            % nibbles to bytes
            bytes = uint8(zeros(min(255, floor(length(nibbles)/2)), 1));
            for ii = 1:length(bytes)
                bytes(ii) = bitor(uint8(nibbles(2*ii-1)), 16*uint8(nibbles(2*ii)));
            end
            % dewhitening
            plen = self.payload_len;
            if self.crc
                % last 2 bytes are CRC16 checkcum
                data = self.dewhitening(bytes(1:plen));
                % calculate CRC checksum
                checksum = self.calc_crc(data(1:plen));
                if isequal(checksum, bytes(plen+1:plen+2))
                    crc_check = true;
                else
                    crc_check = false;
                end
            else
                data = self.dewhitening(bytes(1:len));
                crc_check = false;
            end
        end
        
        function data_w = whitening(self, data)
            % whiten  Whitening process in LoRa
            %
            % input:
            %     data: Data in bytes
            % output:
            %     data_w: Data after whitening

            len = length(data);
            data_w = bitxor(data(1:len), self.whitening_seq(1:len));
        end
        
        function bytes_w = dewhitening(self, bytes)
            % dewhiten  Data Dewhitening
            %
            % input:
            %     bytes: Bytes after deinterleaving
            % output:
            %     bytes_w: Bytes after dewhitening

            len = length(bytes);
            bytes_w = bitxor(uint8(bytes(1:len)), self.whitening_seq(1:len));
        end
        
        function codewords = hamming_encode(self, nibbles)
            for i = 1:length(nibbles)
                if i <= self.sf - 2
                    cr_app = 4;
                else
                    cr_app = self.cr;
                end

                nibble = nibbles(i);
                nibble_bin = [bitget(nibble, 4); bitget(nibble, 3); bitget(nibble, 2); bitget(nibble, 1)];

                % the data_bin is msb first
                if cr_app ~= 1
                    % need hamming parity bits
                    p0 = LoRaPHY.bit_reduce(@bitxor, nibble, [1 2 3]);
                    p1 = LoRaPHY.bit_reduce(@bitxor, nibble, [2 3 4]);
                    p2 = LoRaPHY.bit_reduce(@bitxor, nibble, [1 2 4]);
                    p3 = LoRaPHY.bit_reduce(@bitxor, nibble, [1 3 4]);
                    % we put the data LSB first and append the parity bits
                    b7 = bitshift(nibble_bin(4), 7);
                    b6 = bitshift(nibble_bin(3), 6);
                    b5 = bitshift(nibble_bin(2), 5);
                    b4 = bitshift(nibble_bin(1), 4);
                    b3 = bitshift(p0, 3);
                    b2 = bitshift(p1, 2);
                    b1 = bitshift(p2, 1);
                    b0 = p3;
                    codewords(i) = bitshift(LoRaPHY.word_reduce(@bitor, [b7,b6,b5,b4,b3,b2,b1,b0]), cr_app-4);
                else
                    % coding rate = 4/5 we add a parity bit
                    p4 = mod(sum(nibble_bin), 2);
                    b3 = bitshift(nibble_bin(4), 4);
                    b2 = bitshift(nibble_bin(3), 3);
                    b1 = bitshift(nibble_bin(2), 2);
                    b0 = bitshift(nibble_bin(1), 1);
                    codewords(i) = LoRaPHY.word_reduce(@bitor, [b3,b2,b1,b0,p4]);
                end
            end
        end
        
        function nibbles = hamming_decode(self, codewords)
            nibbles = zeros(length(codewords), 1);
            for i = 1:length(codewords)
                if i <= self.sf - 2
                    cr_app = 4;
                else
                    cr_app = self.cr;
                end

                cw = de2bi(codewords(i), cr_app + 4, 2, 'left-msb');
                nibble = [cw(4), cw(3), cw(2), cw(1)];
                if self.debug_en_ham
                switch cr_app
                    case 4
                        % Don't correct if even number of errors
                        if rem(sum(nibble), 2)
                            s0 = LoRaPHY.word_reduce(@bitxor, [cw(1),cw(2),cw(3),cw(5)]);
                            s1 = LoRaPHY.word_reduce(@bitxor, [cw(2),cw(3),cw(4),cw(6)]);
                            s2 = LoRaPHY.word_reduce(@bitxor, [cw(1),cw(2),cw(4),cw(7)]);
                            syndrom = s0 + bitshift(s1, 1) + bitshift(s2, 2);
                            switch syndrom
                                case 5
                                    nibble(4) = ~nibble(4);
                                case 7
                                    nibble(3) = ~nibble(3);
                                case 3
                                    nibble(2) = ~nibble(2);
                                case 6
                                    nibble(1) = ~nibble(1);
                            end
                        end
                    case 3
                        s0 = LoRaPHY.word_reduce(@bitxor, [cw(1),cw(2),cw(3),cw(5)]);
                        s1 = LoRaPHY.word_reduce(@bitxor, [cw(2),cw(3),cw(4),cw(6)]);
                        s2 = LoRaPHY.word_reduce(@bitxor, [cw(1),cw(2),cw(4),cw(7)]);
                        syndrom = s0 + bitshift(s1, 1) + bitshift(s2, 2);
                        switch syndrom
                            case 5
                                nibble(4) = ~nibble(4);
                            case 7
                                nibble(3) = ~nibble(3);
                            case 3
                                nibble(2) = ~nibble(2);
                            case 6
                                nibble(1) = ~nibble(1);
                        end
                    case 2

                    case 1

                end
                end     % end for self.debug_en_ham
                nibbles(i) = bi2de(nibble, 'left-msb');
            end
        end
        
        function symbols_i = interleave(self, codewords)
            symbols_i = [];
            % Use reduced rate for the first block
            ppm = 8;
            sf_app = self.sf - 2;
            % Create the matrices
            cw_bin=dec2bin(codewords(1:sf_app), ppm);
            % Do the actual interleaving
            for i=1:ppm
                for j=1:sf_app
                    inter_bin(i, j)=cw_bin(mod(i-j-1,sf_app)+1, i);
                end
                % For the first block we add a parity bit and a zero in the end of the lora symbol(reduced rate)
                inter_bin(i, sf_app+1)=num2str(rem(sum(inter_bin(i,1:sf_app)), 2));
                inter_bin(i, sf_app+2)='0';
            end
            symbols_i=[symbols_i; bin2dec(inter_bin)];
            % ppm and sf_app
            ppm = 4 + self.cr;
            sf_app = self.sf;

            % convert input codewords to binary vector
            % if codewords cannot fill a block, fill with zeros
            % FIXME: gr_lora: fill with zeros; COTS lora: fill with a set of fixed
            % number, both donnot affect decoding result
            num_block=ceil(length(codewords(self.sf-2+1:end))/sf_app);
            % zero-padding
            codewords=[codewords (2^ppm-1)*ones(1,sf_app*(num_block)-length(codewords(self.sf-2+1:end)))];
            % random number padding
            % codewords=[codewords randi([0, 2^ppm-1], 1, sf_app*(num_block)-length(codewords(self.sf-2+1:end)))];

            symbols_bin=dec2bin(codewords(self.sf-2+1:end), ppm);
            clear inter_bin cw_bin;
            for n=1:num_block
                % Create the matrices
                cw_bin=symbols_bin(sf_app*(n-1)+1:sf_app*n,:);
                % Do the actual interleaving
                for i=1:ppm
                    for j=1:sf_app
                        inter_bin(i, j) = cw_bin(mod(i-j-1, sf_app)+1, i);
                    end
                end
                % get the interleaved symbols
                symbols_i=[symbols_i; bin2dec(inter_bin)];
            end
        end
        
        function symbols_di = deinterleave(self, symbols)
            byte_len = 8;
            % Do the actual interleaving
            symbols_di = [];

            % Use reduced rate for the first block
            ppm = 8;
            sf_app = self.sf - 2;
            % Create the matrices
            inter_bin = de2bi(symbols(1: ppm), self.sf, 2, 'left-msb');
            inter_bin = inter_bin(:, 1: sf_app);
            % Do the actual interleaving
            for i = 1: ppm
                for j = 1: sf_app
                    deinter_bin(mod(i-j-1, sf_app)+1, i) = inter_bin(i, j);
                end
            end
            % get the interleaved symbols
            symbols_di = [symbols_di; bi2de(deinter_bin, 'left-msb')];

            % User CR for the later block
            num_block = floor(length(symbols(9: end)) / (4 + self.cr));
            symbols_bin = de2bi(symbols(9: end), self.sf, 2, 'left-msb');
            % ppm and sf_app
            ppm = 4 + self.cr;
            sf_app = self.sf;
            clear inter_bin deinter_bin;
            for n = 1: num_block
                % Create the matrices
                inter_bin = symbols_bin(ppm*(n-1)+1: ppm*n, :);
                % Do the actual interleaving
                for i = 1: ppm
                    for j = 1: sf_app
                        deinter_bin(mod(i-j-1,sf_app)+1, i) = inter_bin(i, j);
                    end
                end
                % get the interleaved symbols
                symbols_di=[symbols_di; bi2de([zeros(sf_app, byte_len - ppm) deinter_bin], 'left-msb')];
            end
        end
        
        function symbols_di_bin = deinterleave_bin(self, symbols_bin)
            byte_len = 8;
            % Do the actual interleaving
            symbols_di_bin = [];

            % Use reduced rate for the first block
            ppm = 8;
            sf_app = self.sf - 2;
            % Create the matrices
            inter_bin = symbols_bin(1: ppm, 1: sf_app);
            % Do the actual interleaving
            for i = 1: ppm
                for j = 1: sf_app
                    deinter_bin(mod(i-j-1, sf_app)+1, i) = inter_bin(i, j);
                end
            end
            % get the interleaved symbols
            symbols_di_bin = [symbols_di_bin; deinter_bin];

            % User CR for the later block
            num_block = floor(length(symbols_bin(9: end, :)) / (4 + self.cr));
            symbols_bin = symbols_bin(9: end, :);
            % ppm and sf_app
            ppm = 4 + self.cr;
            sf_app = self.sf;
            clear inter_bin deinter_bin;
            for n = 1: num_block
                % Create the matrices
                inter_bin = symbols_bin(ppm*(n-1)+1: ppm*n, :);
                % Do the actual interleaving
                for i = 1: ppm
                    for j = 1: sf_app
                        deinter_bin(mod(i-j-1,sf_app)+1, i) = inter_bin(i, j);
                    end
                end
                % get the interleaved symbols
                symbols_di_bin=[symbols_di_bin; [zeros(sf_app, byte_len - ppm) deinter_bin]];
            end
        end
        
        function symbols = gray_decoding(self, symbols_i)
            symbols = zeros(length(symbols_i), 1);
            for i = 1:length(symbols_i)
                symbols(i) = symbols_i(i);
                for j = 1: self.sf 
                    symbols(i) = bitxor(symbols(i), bitshift(symbols_i(i),-j));
                end
                % do the shift of 1
                symbols(i) = mod(symbols(i)+1, bitshift(1, self.sf));
            end
        end
        
        function symbols_g = gray_encoding(self, symbols)
            % do the shift of -1
            symbols = mod(symbols - 1, bitshift(1, self.sf));
            symbols_g = bitxor(symbols, floor(bitsra(symbols, 1)));
        end
        
        function checksum = calc_crc(self, data)
            % calc_crc  Calculate payload CRC
            %
            % input:
            %     data: Data in bytes
            % output:
            %     checksum: CRC result

            switch length(data)
                case 0
                    checksum = [0; 0];
                case 1
                    checksum = [data(end); 0];
                case 2
                    checksum = [data(end); data(end-1)];
                otherwise
                    input = data(1:end-2);
                    seq = self.crc_generator(reshape(logical(de2bi(input, 8, 2, 'left-msb'))', [], 1));
                    checksum_b1 = bitxor(bi2de(seq(end-7:end)', 'left-msb'), data(end));
                    checksum_b2 = bitxor(bi2de(seq(end-15:end-8)', 'left-msb'), data(end-1));
                    checksum = [checksum_b1; checksum_b2];
            end
        end
        
        function pk = dechirp(self, x, is_up)
            % dechirp  Apply dechirping on the symbol starts from index x
            %
            % input:
            %     x: Start index of a symbol
            %     is_up: `true` if applying up-chirp dechirping
            %            `false` if applying down-chirp dechirping
            % output:
            %     pk: Peak in FFT results of dechirping
            %         pk = (height, index)

            if nargin == 3 && ~is_up
                c = self.upchirp;
            else
                c = self.downchirp;
            end
            ft = fft(self.sig(x:x+self.num_samples-1).*c, self.fft_size);
            ft_ = abs(ft(1:self.bin_size)) + abs(ft(self.fft_size-self.bin_size+1:self.fft_size));
            pk = LoRaPHY.topn([ft_ (1:self.bin_size).'], 1);
        end
        
        
        function time_ms = time_on_air(self, plen)
            % time_on_air  Calculate the flying time of a LoRa packet
            %
            % input:
            %     plen: Payload length
            % output:
            %     time_ms: Flying time (in milliseconds)

            sym_num = self.calc_sym_num(plen);
            % milliseconds
            time_ms = (sym_num + 4.25 + self.preamble_len) * (2^self.sf/self.bw) * 1000;
        end
        
        function samp_num = calc_samp_num(self, plen)
            % calc_sym_num  Calculate number of samples on 2*bw signals
            %
            % input:
            %     plen: Payload length
            % output:
            %     samp_num: Number of samples
            
            sym_num = self.calc_sym_num(plen);
            samp_num = (sym_num + 4.25 + self.preamble_len) * self.num_samples;
        end
        
        function sym_num = calc_sym_num(self, plen)
            % calc_sym_num  Calculate number of symbols
            %
            % input:
            %     plen: Payload length
            % output:
            %     sym_num: Number of symbols

            sym_num = double(8 + max((4+self.cr)*ceil(double((2*plen-self.sf+7+4*self.crc-5*(1-self.has_header)))/double(self.sf-2*self.ldr)), 0));
        end
    end
    
    methods(Static)
        function b = bit_reduce(fn, w, pos)
            b = bitget(w, pos(1));
            for i = 2:length(pos)
                b = fn(b, bitget(w, pos(i)));
            end
        end

        function w = word_reduce(fn, ws)
            w = ws(1);
            for i = 2:length(ws)
                w = fn(w, ws(i));
            end
        end
        
        function y = chirp(sf, bw, fs, sym, is_up)
            % Generate a LoRa symbol chirp
            % input:
            %       sf: Spreading factor
            %       bw: Bandwidth
            %       fs: Sample Frequency
            %       sym: Symbol value
            %       is_up: `true` if generating an upchirp
            %              `false` if generating a downchirp
            % output:
            %       y: Generated LoRa symbol
            N = 2^sf;
            fs_bw = fs/bw;
            samp_per_sym = round(fs_bw*N);
            n_fold = round(fs_bw*(N - sym));  % chirp folding point
            y = zeros(samp_per_sym, 1);
            
            n1 = 0: n_fold - 1;
            n2 = n_fold: N * fs_bw - 1;
            y(1: n_fold) = exp(1i*2*pi*(1/(2*N)*(1/fs_bw)^2*n1.^2+(sym/N-0.5)*(1/fs_bw)*n1));
            y(n_fold + 1: N * fs_bw) = exp(1i*2*pi*(1/(2*N)*(1/fs_bw)^2*n2.^2+(sym/N-1.5)*(1/fs_bw)*n2));

            if ~is_up
                y = conj(y);
            end
        end
        
        function y = add_cfo(sig, cfo, bw, fs, x)
            if nargin == 4
                x = 0;
            end
            n = round(fs/bw);
            y = sig .* (exp(1j*2*pi*cfo/bw * (x:1/n:x+length(sig)/n-1/n)).');
        end
        
        function y = mv2range(x, lb, ub)
            x(x < lb) = x(x < lb) + (ub - lb);
            x(x >= ub) = x(x >= ub) - (ub - lb);
            y = x;
        end
        
    end
end